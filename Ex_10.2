const express = require("express");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const cors = require("cors");
const app = express();
app.use(cors());
app.use(express.json());
const PORT = process.env.PORT || 5000;
const JWT_SECRET = process.env.JWT_SECRET || "supersecretkey";

const users = [];
const posts = [];

function generateId(prefix="id"){
  return prefix + "_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,9);
}

async function hashPassword(p){ return await bcrypt.hash(p, 10); }
async function comparePassword(p, h){ return await bcrypt.compare(p, h); }

function generateToken(user){
  return jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: "6h" });
}

function authenticate(req, res, next){
  const authHeader = req.headers.authorization;
  if(!authHeader) return res.status(401).json({ error: "Authorization required" });
  const parts = authHeader.split(" ");
  if(parts.length !== 2 || parts[0] !== "Bearer") return res.status(401).json({ error: "Malformed token" });
  const token = parts[1];
  jwt.verify(token, JWT_SECRET, (err, payload) => {
    if(err) return res.status(403).json({ error: "Invalid or expired token" });
    req.user = payload;
    next();
  });
}

app.post("/register", async (req, res) => {
  const { username, password, bio } = req.body;
  if(!username || !password) return res.status(400).json({ error: "username and password required" });
  if(users.find(u => u.username === username)) return res.status(409).json({ error: "username taken" });
  const id = generateId("u");
  const passwordHash = await hashPassword(password);
  const newUser = { id, username, passwordHash, bio: bio || "", createdAt: new Date().toISOString() };
  users.push(newUser);
  const token = generateToken(newUser);
  res.status(201).json({ id: newUser.id, username: newUser.username, bio: newUser.bio, token });
});

app.post("/login", async (req, res) => {
  const { username, password } = req.body;
  if(!username || !password) return res.status(400).json({ error: "username and password required" });
  const user = users.find(u => u.username === username);
  if(!user) return res.status(401).json({ error: "invalid credentials" });
  const ok = await comparePassword(password, user.passwordHash);
  if(!ok) return res.status(401).json({ error: "invalid credentials" });
  const token = generateToken(user);
  res.json({ token, id: user.id, username: user.username, bio: user.bio });
});

app.get("/me", authenticate, (req, res) => {
  const user = users.find(u => u.id === req.user.id);
  if(!user) return res.status(404).json({ error: "user not found" });
  res.json({ id: user.id, username: user.username, bio: user.bio, createdAt: user.createdAt });
});

app.get("/users/:id", (req, res) => {
  const user = users.find(u => u.id === req.params.id);
  if(!user) return res.status(404).json({ error: "user not found" });
  res.json({ id: user.id, username: user.username, bio: user.bio, createdAt: user.createdAt });
});

app.post("/posts", authenticate, (req, res) => {
  const { title, content } = req.body;
  if(!title || !content) return res.status(400).json({ error: "title and content required" });
  const author = users.find(u => u.id === req.user.id);
  if(!author) return res.status(404).json({ error: "author not found" });
  const post = { id: generateId("p"), title, content, authorId: author.id, authorName: author.username, comments: [], createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
  posts.unshift(post);
  res.status(201).json(post);
});

app.get("/posts", (req, res) => {
  const summary = posts.map(p => ({ id: p.id, title: p.title, authorName: p.authorName, commentsCount: p.comments.length, createdAt: p.createdAt }));
  res.json(summary);
});

app.get("/posts/:id", (req, res) => {
  const post = posts.find(p => p.id === req.params.id);
  if(!post) return res.status(404).json({ error: "post not found" });
  res.json(post);
});

app.put("/posts/:id", authenticate, (req, res) => {
  const post = posts.find(p => p.id === req.params.id);
  if(!post) return res.status(404).json({ error: "post not found" });
  if(post.authorId !== req.user.id) return res.status(403).json({ error: "only author can edit" });
  const { title, content } = req.body;
  if(title) post.title = title;
  if(content) post.content = content;
  post.updatedAt = new Date().toISOString();
  res.json(post);
});

app.delete("/posts/:id", authenticate, (req, res) => {
  const idx = posts.findIndex(p => p.id === req.params.id);
  if(idx === -1) return res.status(404).json({ error: "post not found" });
  if(posts[idx].authorId !== req.user.id) return res.status(403).json({ error: "only author can delete" });
  posts.splice(idx,1);
  res.json({ message: "post deleted" });
});

app.post("/posts/:id/comments", authenticate, (req, res) => {
  const post = posts.find(p => p.id === req.params.id);
  if(!post) return res.status(404).json({ error: "post not found" });
  const { content } = req.body;
  if(!content) return res.status(400).json({ error: "content required" });
  const commenter = users.find(u => u.id === req.user.id);
  const comment = { id: generateId("c"), content, authorId: commenter.id, authorName: commenter.username, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
  post.comments.push(comment);
  res.status(201).json(comment);
});

app.put("/posts/:postId/comments/:commentId", authenticate, (req, res) => {
  const post = posts.find(p => p.id === req.params.postId);
  if(!post) return res.status(404).json({ error: "post not found" });
  const comment = post.comments.find(c => c.id === req.params.commentId);
  if(!comment) return res.status(404).json({ error: "comment not found" });
  if(comment.authorId !== req.user.id) return res.status(403).json({ error: "only author can edit comment" });
  const { content } = req.body;
  if(!content) return res.status(400).json({ error: "content required" });
  comment.content = content;
  comment.updatedAt = new Date().toISOString();
  res.json(comment);
});

app.delete("/posts/:postId/comments/:commentId", authenticate, (req, res) => {
  const post = posts.find(p => p.id === req.params.postId);
  if(!post) return res.status(404).json({ error: "post not found" });
  const cIdx = post.comments.findIndex(c => c.id === req.params.commentId);
  if(cIdx === -1) return res.status(404).json({ error: "comment not found" });
  if(post.comments[cIdx].authorId !== req.user.id && post.authorId !== req.user.id) return res.status(403).json({ error: "only comment author or post author can delete" });
  post.comments.splice(cIdx,1);
  res.json({ message: "comment deleted" });
});

app.get("/users/:id/posts", (req, res) => {
  const userPosts = posts.filter(p => p.authorId === req.params.id).map(p => ({ id: p.id, title: p.title, createdAt: p.createdAt, commentsCount: p.comments.length }));
  res.json(userPosts);
});

app.get("/explore", (req, res) => {
  const recent = posts.slice(0,10).map(p => ({ id: p.id, title: p.title, snippet: p.content.slice(0,150), authorName: p.authorName, commentsCount: p.comments.length }));
  res.json(recent);
});

app.listen(PORT, () => { console.log("Blog platform API running on port " + PORT); });
